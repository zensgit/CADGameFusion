name: Core Strict - Exports, Validation, Comparison

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      rtol:
        description: 'Field comparison rtol (e.g., 1e-6 for Linux/macOS, 1e-5 for Windows)'
        required: false
        default: '1e-6'
      use_vcpkg:
        description: 'Use vcpkg toolchain and cache (slower, full deps)'
        required: false
        default: 'false'

jobs:
  exports-validate-compare:
    runs-on: ubuntu-latest
    concurrency:
      group: core-strict-exports-${{ github.ref }}
      cancel-in-progress: true

    steps:
      - uses: actions/checkout@v4

      - name: Cache vcpkg
        if: github.event.inputs.use_vcpkg == 'true'
        uses: actions/cache@v3
        with:
          path: |
            C:\vcpkg\installed
            C:\vcpkg\packages
            ~/vcpkg/installed
            ~/vcpkg/packages
            ~/.cache/vcpkg
            ~/AppData/Local/vcpkg/archives
          key: ${{ runner.os }}-vcpkg-${{ hashFiles('**/vcpkg.json') }}-v3
          restore-keys: ${{ runner.os }}-vcpkg-

      - name: Setup vcpkg
        if: github.event.inputs.use_vcpkg == 'true'
        shell: bash
        run: |
          if [ "${{ runner.os }}" == "Windows" ]; then VCPKG_DIR="C:/vcpkg"; else VCPKG_DIR="$HOME/vcpkg"; fi
          if [ -d "$VCPKG_DIR/.git" ]; then (cd "$VCPKG_DIR" && git pull); else rm -rf "$VCPKG_DIR" && git clone https://github.com/Microsoft/vcpkg.git "$VCPKG_DIR"; fi
          if [ "${{ runner.os }}" == "Windows" ]; then (cd "$VCPKG_DIR" && ./bootstrap-vcpkg.bat -disableMetrics); else (cd "$VCPKG_DIR" && ./bootstrap-vcpkg.sh -disableMetrics); fi
          echo "VCPKG_ROOT=$VCPKG_DIR" >> $GITHUB_ENV
          echo "$VCPKG_DIR" >> $GITHUB_PATH

      - name: OS deps
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake ninja-build build-essential python3-pip
          python3 -m pip install --user --upgrade pip jsonschema

      - name: Configure
        shell: bash
        run: |
          if [ "${{ github.event.inputs.use_vcpkg }}" == "true" ]; then
            TOOLCHAIN="$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake"
            cmake -S . -B build -DCMAKE_TOOLCHAIN_FILE="$TOOLCHAIN" -DCMAKE_BUILD_TYPE=Release -DBUILD_EDITOR_QT=OFF -DCADGF_USE_NLOHMANN_JSON=ON -DCADGF_SORT_RINGS=ON
          else
            cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DBUILD_EDITOR_QT=OFF -DCADGF_USE_NLOHMANN_JSON=ON -DCADGF_SORT_RINGS=ON -G Ninja
          fi

      - name: Check vendored nlohmann/json header (hard check)
        shell: bash
        run: |
          HDR="tools/third_party/json.hpp"
          if [ -f "$HDR" ]; then
            if grep -q "NLOHMANN_JSON_VERSION_" "$HDR"; then
              echo "[OK] Detected nlohmann/json header with version macros"
              grep -E "#define NLOHMANN_JSON_VERSION_(MAJOR|MINOR|PATCH)" -m3 "$HDR" || true
            else
              echo "::error ::tools/third_party/json.hpp does not appear to be the official nlohmann/json single-header."
              echo "       Replace this file with the upstream json.hpp to enable full parser."
              exit 1
            fi
          else
            echo "::error ::tools/third_party/json.hpp not found. Please vendor the official nlohmann/json.hpp as json.hpp."
            exit 1
          fi

      - name: Build export_cli
        shell: bash
        run: |
          # Try to download prebuilt export_cli from build workflow
          echo "Attempting to download built tools artifact..."
          gh --version >/dev/null 2>&1 || echo "GitHub CLI not available; skipping" 
          if command -v gh >/dev/null 2>&1; then
            echo "(Optional) Download via gh is not configured in CI token; skipping"
          fi
          # Fallback to local build
          cmake --build build --config Release --target export_cli --parallel 2 || cmake --build build --config Release --parallel 2

      - name: Build spec parsing test
        shell: bash
        run: |
          cmake --build build --config Release --target test_spec_parsing --parallel 2 || true

      - name: Locate export_cli
        id: findcli
        shell: bash
        run: |
          set -e
          CAND=(
            "build/bin/export_cli"
            "build/bin/export_cli.exe"
            "build/tools/export_cli"
            "build/tools/Release/export_cli.exe"
            "build/Release/export_cli"
            "build/Release/export_cli.exe"
          )
          for p in "${CAND[@]}"; do
            if [ -f "$p" ]; then echo "path=$p" >> $GITHUB_OUTPUT; exit 0; fi
          done
          echo "::error::export_cli not found"; exit 1

      - name: Generate scenes via export_cli
        shell: bash
        run: |
          EXPORT_CLI="${{ steps.findcli.outputs.path }}"
          for SCENE in sample holes multi units complex; do
            "$EXPORT_CLI" --out build/exports --scene "$SCENE"
          done
          if [ -f tools/specs/scene_complex_spec.json ]; then
            "$EXPORT_CLI" --out build/exports --spec tools/specs/scene_complex_spec.json
          fi
          if [ -f tools/specs/scene_concave_spec.json ]; then
            "$EXPORT_CLI" --out build/exports --spec tools/specs/scene_concave_spec.json
          fi
          if [ -f tools/specs/scene_nested_holes_spec.json ]; then
            "$EXPORT_CLI" --out build/exports --spec tools/specs/scene_nested_holes_spec.json
          fi

      - name: Validate scenes (schema + stats)
        shell: bash
        run: |
          python3 -m pip install --user --upgrade pip >/dev/null 2>&1 || true
          # Cache pip
          PIP_DIR="$HOME/.cache/pip"
          mkdir -p "$PIP_DIR"
          python3 -m pip install --user jsonschema >/dev/null 2>&1 || true
          STATS_FILE=consistency_stats.txt
          : > "$STATS_FILE"
          for d in build/exports/scene_cli_*; do
            [ -d "$d" ] || continue
            python3 tools/validate_export.py "$d" --schema --stats-out "$STATS_FILE"
          done
          echo "# Strict Exports Validation Report" > test_report.md
          echo "" >> test_report.md
          echo "## Consistency Stats" >> test_report.md
          echo '```' >> test_report.md
          cat "$STATS_FILE" >> test_report.md
          echo '```' >> test_report.md

      - name: Normalization checks
        shell: bash
        run: |
          echo "Running normalization checks (orientation/start/sortRings)"
          python3 tools/test_normalization.py build/exports

      - name: Validate spec JSONs against schema
        shell: bash
        run: |
          if ls tools/specs/*_spec.json >/dev/null 2>&1; then
            echo "Validating spec JSON files against docs/schemas/cli_spec.schema.json"
            python3 - << 'EOF'
          import json, glob, sys
          from pathlib import Path
          try:
              import jsonschema
          except ImportError:
              print('jsonschema not installed; skipping spec schema validation')
              sys.exit(0)
          schema = json.load(open('docs/schemas/cli_spec.schema.json','r'))
          failed = False
          for p in glob.glob('tools/specs/*_spec.json'):
              data = json.load(open(p,'r'))
              try:
                  jsonschema.validate(instance=data, schema=schema)
                  print('[OK]', p)
              except Exception as e:
                  print('[FAIL]', p, e)
                  failed = True
          sys.exit(1 if failed else 0)
          EOF
          else
            echo "No spec JSON files found under tools/specs"
          fi

      - name: Structure comparison (strong selected)
        shell: bash
        run: |
          set -e
          declare -A MAP
          MAP["scene_cli_sample"]=scene_sample
          MAP["scene_cli_holes"]=scene_holes
          MAP["scene_cli_multi"]=scene_multi_groups
          MAP["scene_cli_units"]=scene_units
          MAP["scene_cli_complex"]=scene_complex
          MAP["scene_cli_scene_complex_spec"]=scene_complex
          MAP["scene_cli_scene_concave_spec"]=scene_concave
          MAP["scene_cli_scene_nested_holes_spec"]=scene_nested_holes
          COMPARISON_FAILED=false
          for L in build/exports/scene_cli_*; do
            [ -d "$L" ] || continue
            NAME=$(basename "$L")
            R="sample_exports/${MAP[$NAME]}"
            [ -d "$R" ] || continue
            if python3 tools/compare_export_to_sample.py "$L" "$R"; then
              echo "[OK] $NAME structure matches"
            else
              if [ "$NAME" = "scene_cli_sample" ] || [ "$NAME" = "scene_cli_holes" ] || [ "$NAME" = "scene_cli_complex" ] || [ "$NAME" = "scene_cli_scene_complex_spec" ] || [ "$NAME" = "scene_cli_scene_concave_spec" ] || [ "$NAME" = "scene_cli_scene_nested_holes_spec" ]; then
                echo "::error::$NAME must match structure exactly"
                COMPARISON_FAILED=true
              else
                echo "[WARN] $NAME structural diffs allowed"
              fi
            fi
          done
          if [ "$COMPARISON_FAILED" = true ]; then exit 1; fi

      - name: Field-level comparison (strict)
        shell: bash
        env:
          FIELD_COMPARE_RTOL: ${{ github.event.inputs.rtol || '1e-6' }}
        run: |
          RTOL="${FIELD_COMPARE_RTOL:-1e-6}"
          # Adjust tolerance for Windows floating point precision differences
          if [ "${{ runner.os }}" == "Windows" ] && [ "$RTOL" == "1e-6" ]; then
            RTOL="1e-5"
            echo "Adjusted rtol to $RTOL for Windows platform"
          fi
          echo "rtol=$RTOL" >> $GITHUB_OUTPUT
          python3 tools/compare_fields.py build/exports/scene_cli_sample sample_exports/scene_sample --rtol "$RTOL" --json-out field_sample.json --meta-mode on --mode full
          python3 tools/compare_fields.py build/exports/scene_cli_holes sample_exports/scene_holes --rtol "$RTOL" --json-out field_holes.json --meta-mode on --mode full
          python3 tools/compare_fields.py build/exports/scene_cli_complex sample_exports/scene_complex --rtol "$RTOL" --json-out field_complex.json --meta-mode on --mode full
          python3 tools/compare_fields.py build/exports/scene_cli_scene_complex_spec sample_exports/scene_complex --rtol "$RTOL" --json-out field_spec_complex.json --meta-mode on --mode full
          python3 tools/compare_fields.py build/exports/scene_cli_units sample_exports/scene_units --rtol "$RTOL" --json-out field_units.json --mode full --meta-mode on --allow-gltf-mismatch
          # Upgrade concave/nested_holes to full mode comparisons as well
          python3 tools/compare_fields.py build/exports/scene_cli_scene_concave_spec sample_exports/scene_sample --rtol "$RTOL" --json-out field_concave.json --mode full --meta-mode on --allow-gltf-mismatch
          python3 tools/compare_fields.py build/exports/scene_cli_scene_nested_holes_spec sample_exports/scene_holes --rtol "$RTOL" --json-out field_nested_holes.json --mode full --meta-mode on --allow-gltf-mismatch
          python3 tools/compare_fields.py build/exports/scene_cli_multi sample_exports/scene_multi_groups --rtol "$RTOL" --json-out field_multi.json --mode full --meta-mode on --allow-gltf-mismatch

      - name: Run spec parsing smoke test
        shell: bash
        run: |
          echo "Running spec parsing smoke test"
          if [ -f "build/tests/tools/test_spec_parsing" ]; then
            build/tests/tools/test_spec_parsing
          elif [ -f "build/tests/tools/Release/test_spec_parsing.exe" ]; then
            build/tests/tools/Release/test_spec_parsing.exe
          else
            echo "[WARN] test_spec_parsing not found (build config/platform)"
          fi

      - name: Upload reports
        uses: actions/upload-artifact@v4
        with:
          name: strict-exports-reports-${{ runner.os }}
          path: |
            test_report.md
            consistency_stats.txt
            field_*.json
